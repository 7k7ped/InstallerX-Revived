package com.rosan.installer.ui.page.installer.dialog.inner

import android.content.Intent
import android.net.Uri
import android.provider.Settings
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import com.rosan.installer.R
import com.rosan.installer.data.common.util.addAll
import com.rosan.installer.data.installer.repo.InstallerRepo
import com.rosan.installer.data.recycle.util.useUserService
import com.rosan.installer.data.settings.model.room.entity.ConfigEntity
import com.rosan.installer.ui.page.installer.dialog.DialogParams
import com.rosan.installer.ui.page.installer.dialog.DialogParamsType
import com.rosan.installer.ui.page.installer.dialog.DialogViewAction
import com.rosan.installer.ui.page.installer.dialog.DialogViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import timber.log.Timber

@Composable
fun installSuccessDialog( // 小写开头
    installer: InstallerRepo,
    viewModel: DialogViewModel
): DialogParams {
    val context = LocalContext.current
    val currentPackageName by viewModel.currentPackageName.collectAsState()
    val coroutineScope = rememberCoroutineScope()

    // Collect preInstallAppInfo (represents the state *before* the successful install)
    // val currentPreInstallInfo by viewModel.preInstallAppInfo.collectAsState()

    val packageName = currentPackageName ?: installer.analysisResults.firstOrNull()?.packageName ?: ""

    // Call InstallInfoDialog, passing the collected preInstallAppInfo.
    // InstallInfoDialog will now handle the logic of displaying one or two versions.
    val baseParams = installInfoDialog(
        installer = installer,
        viewModel = viewModel,
        onTitleExtraClick = {
            if (packageName.isNotEmpty()) {
                context.startActivity(
                    Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                        .setData(Uri.fromParts("package", packageName, null))
                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                )
            }
            viewModel.dispatch(DialogViewAction.Background)
        }
    )

    // Only override the buttons
    return baseParams.copy(
        // Subtitle is now correctly generated by InstallInfoDialog
        buttons = DialogButtons(
            DialogParamsType.InstallerInstallSuccess.id
        ) {
            val list = mutableListOf<DialogButton>()
            val intent =
                if (packageName.isNotEmpty()) context.packageManager.getLaunchIntentForPackage(
                    packageName
                ) else null
            if (intent != null) {
                list.add(DialogButton(stringResource(R.string.open)) {
                    coroutineScope.launch(Dispatchers.IO) {
                        Timber.tag("HybridStart").i("Attempting privileged API start for $packageName...")

                        var forceStartSuccess = false
                        // Use unified UserService to access privileged methods
                        if (installer.config.authorizer == ConfigEntity.Authorizer.Root ||
                            installer.config.authorizer == ConfigEntity.Authorizer.Shizuku
                        )
                            useUserService(installer.config) { userService ->
                                try {
                                    forceStartSuccess = userService.privileged.startActivityPrivileged(intent)
                                    Timber.tag("HybridStart")
                                        .d("privileged.startActivityPrivileged returned: $forceStartSuccess")
                                } catch (e: Exception) {
                                    Timber.tag("HybridStart").e(e, "Call to privileged.startActivityPrivileged failed.")
                                    forceStartSuccess = false
                                }
                            }

                        if (forceStartSuccess) {
                            // API Method succeeded, close the dialog
                            Timber.tag("HybridStart")
                                .i("Privileged API start succeeded for $packageName. Closing dialog.")
                            viewModel.dispatch(DialogViewAction.Close)
                        } else {
                            // Use standard Android intent as fallback
                            Timber.tag("HybridStart")
                                .w("Privileged API start failed. Falling back to standard Android intent.")
                            // Switch to Main dispatcher for UI operations
                            withContext(Dispatchers.Main) {
                                context.startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
                                coroutineScope.launch {
                                    if (installer.config.authorizer == ConfigEntity.Authorizer.Dhizuku) {
                                        // Wait for the auto-close countdown
                                        delay(viewModel.autoCloseCountDown * 1000L)
                                        Timber.tag("InstallSuccessDialog").d(
                                            "App $packageName not detected in foreground after ${viewModel.autoCloseCountDown} seconds. Dialog will close itself."
                                        )
                                        viewModel.dispatch(DialogViewAction.Close)
                                    }
                                }
                            }
                        }
                    }
                })
            }
            list.addAll(
                /*DialogButton(stringResource(R.string.previous), 2f) {
                    viewModel.dispatch(DialogViewAction.InstallPrepare)
                },*/
                DialogButton(stringResource(R.string.finish)) {
                    viewModel.dispatch(DialogViewAction.Close)
                }
            )
            return@DialogButtons list
        }
    )
}