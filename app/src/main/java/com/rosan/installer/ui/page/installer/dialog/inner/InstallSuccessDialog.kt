package com.rosan.installer.ui.page.installer.dialog.inner

// Remove unused imports related to building subtitle manually
// import androidx.compose.foundation.basicMarquee
// import androidx.compose.foundation.layout.Arrangement
// import androidx.compose.foundation.layout.Column
// import androidx.compose.foundation.layout.size
// import androidx.compose.material.icons.Icons
// import androidx.compose.material.icons.filled.ArrowDownward
// import androidx.compose.material3.Icon
// import androidx.compose.material3.MaterialTheme
// import androidx.compose.material3.Text
// import androidx.compose.ui.Alignment
// import androidx.compose.ui.Modifier
// import androidx.compose.ui.text.style.TextAlign
// import androidx.compose.ui.unit.dp
// import com.rosan.installer.data.app.model.entity.AppEntity // No longer needed here
// import com.rosan.installer.data.app.util.sortedBest // No longer needed here
import android.content.Intent
import android.net.Uri
import android.provider.Settings
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import com.rosan.installer.R
import com.rosan.installer.data.common.util.addAll
import com.rosan.installer.data.installer.repo.InstallerRepo
import com.rosan.installer.data.recycle.util.useUserService
import com.rosan.installer.data.settings.model.room.entity.ConfigEntity
import com.rosan.installer.ui.page.installer.dialog.DialogParams
import com.rosan.installer.ui.page.installer.dialog.DialogParamsType
import com.rosan.installer.ui.page.installer.dialog.DialogViewAction
import com.rosan.installer.ui.page.installer.dialog.DialogViewModel
import com.rosan.installer.util.toast
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import timber.log.Timber

@Composable
fun installSuccessDialog( // 小写开头
    installer: InstallerRepo,
    viewModel: DialogViewModel
): DialogParams {
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()

    // Collect preInstallAppInfo (represents the state *before* the successful install)
    val currentPreInstallInfo by viewModel.preInstallAppInfo.collectAsState()
    val currentPackageName by viewModel.currentPackageName.collectAsState()
    val packageName = currentPackageName ?: installer.entities.filter { it.selected }.map { it.app }
        .firstOrNull()?.packageName ?: ""

    // Call InstallInfoDialog, passing the collected preInstallAppInfo.
    // InstallInfoDialog will now handle the logic of displaying one or two versions.
    val baseParams = InstallInfoDialog(
        installer = installer,
        viewModel = viewModel,
        preInstallAppInfo = currentPreInstallInfo, // Pass the potentially null old info
        onTitleExtraClick = {
            if (packageName.isNotEmpty()) {
                context.startActivity(
                    Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                        .setData(Uri.fromParts("package", packageName, null))
                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                )
            }
            viewModel.dispatch(DialogViewAction.Background)
        }
    )

    // Only override the buttons
    return baseParams.copy(
        // Subtitle is now correctly generated by InstallInfoDialog
        buttons = DialogButtons(
            DialogParamsType.InstallerInstallSuccess.id
        ) {
            val list = mutableListOf<DialogButton>()
            val intent =
                if (packageName.isNotEmpty()) context.packageManager.getLaunchIntentForPackage(
                    packageName
                ) else null
            if (intent != null) {
                list.add(DialogButton(stringResource(R.string.open)) {
                    context.startActivity(intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
                    coroutineScope.launch {
                        if (isAppInForeground(packageName, installer.config)) {
                            Timber.tag("InstallSuccessDialog").d(
                                "App $packageName is in foreground, closing dialog."
                            )
                            viewModel.dispatch(DialogViewAction.Close)
                        } else {
                            // Explicitly handle the case where the app is not in the foreground
                            // or the check timed out. This makes the logic clearer.
                            if (installer.config.authorizer == ConfigEntity.Authorizer.Dhizuku) {
                                Timber.tag("InstallSuccessDialog").d(
                                    "Dhizuku expected, closing dialog."
                                )
                            } else {
                                Timber.tag("InstallSuccessDialog").d(
                                    "App $packageName not detected in foreground after 10 seconds. Dialog will close itself."
                                )
                                withContext(Dispatchers.Main) {
                                    context.toast("等待应用启动超时，自动关闭安装窗口。")
                                }
                            }
                            // ALWAYS close the dialog afterwards, regardless of whether the app
                            // was detected in the foreground or the check timed out.
                            viewModel.dispatch(DialogViewAction.Close)
                        }
                    }
                })
            }
            list.addAll(
                DialogButton(stringResource(R.string.previous), 2f) {
                    viewModel.dispatch(DialogViewAction.InstallPrepare)
                },
                DialogButton(stringResource(R.string.finish), 1f) {
                    viewModel.dispatch(DialogViewAction.Close)
                }
            )
            return@DialogButtons list
        }
    )
}

/**
 * 使用高权限Shell轮询检查指定包名的应用是否位于前台。
 *
 * @param targetPackageName 要检查的应用包名。
 * @param config 用于执行高权限Shell命令的配置实体。
 * @return `true` 如果应用成功切换到前台, `false` 如果超时。
 */
private suspend fun isAppInForeground(
    targetPackageName: String,
    config: ConfigEntity
): Boolean {
    // Use withTimeoutOrNull to limit the execution time to 10 seconds
    val result =
        withTimeoutOrNull(10000L) {
            while (true) {
                // Execute the function in IO thread
                val topApp = withContext(Dispatchers.IO) {
                    // Call the function to get the top app package name
                    getTopApp(config)
                }

                Timber.tag("isAppInForeground").d("Checking foreground app: $topApp")

                if (topApp == targetPackageName) {
                    Timber.tag("isAppInForeground")
                        .d("Target App $targetPackageName is in foreground.")
                    return@withTimeoutOrNull true
                }

                delay(1000L) // Perform a check every 1 second
            }

            if (config.authorizer == ConfigEntity.Authorizer.Dhizuku) {
                Timber.tag("isAppInForeground").d("Dhizuku detected, false as default.")
            } else {
                Timber.tag("isAppInForeground")
                    .d("Target App $targetPackageName not found in foreground, timing out.")
            }

            false
        }
    return result == true // Return true if the app was found in foreground, false if timed out
}

/**
 * 获取当前前台应用的包名。
 *
 * @param config 用于执行高权限Shell命令的配置实体。
 * @return 当前前台应用的包名，如果无法获取则返回空字符串。
 */
// TODO 使用 UsageStatsManager API 来替代 dumpsys 命令。
private fun getTopApp(
    config: ConfigEntity
): String {
    var topAppPackage = ""

    // Use the userService to execute privileged commands
    useUserService(config) { userService ->
        try {
            /**
             * Exec `dumpsys` command to get the current focused window.
             * This command is unstable and may change in future Android versions.
             * Tested by Shizuku:
             *  Tested on OneUI 7.0 (Android 15)
             *  Tested on HyperOS 2.0.200 (Android 15)
             */
            val command = "dumpsys window | grep mCurrentFocus"
            // in order to use shell environment, we need to use execArr
            // otherwise, pipeline symbols like '|' won't work
            val cmdArray = arrayOf("/system/bin/sh", "-c", command)
            // Call the interface method via userService.privileged
            val result = userService.privileged.execArr(cmdArray)
            Timber.tag("getTopApp")
                .d("Result of executing '${cmdArray.contentToString()}': $result")

            topAppPackage = if (result.isBlank()) {
                // Result is empty, return empty string
                ""
            } else {
                // Analyze the result to extract the package name
                val componentPart = result.split(' ').lastOrNull { it.contains('/') }
                componentPart?.substringBefore('/') ?: ""
            }
        } catch (_: UnsupportedOperationException) {
            Timber.tag("getTopApp")
                .d("Authorizer does not support shell access, returning empty string")
        } catch (e: Exception) {
            Timber.tag("getTopApp").e(e, "Exception while getting top app package")
            // return empty string if any exception occurs
            topAppPackage = ""
        }
    }
    // Return the package name of the top app extracted in the lambda
    Timber.tag("getTopApp").d("Acquired Top App Package Name: $topAppPackage")
    return topAppPackage
}